---
title: "Odds Ratio"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library('tidyverse')
library('knitr')

```

### Summary

A simple recreation of the table shown in Keith Cheung's [Fixed-Odds Betting and Traditional Odds]("http://www.sportstradingnetwork.com/article/fixed-odds-betting-traditional-odds/") article.  
This includes a function to find the value 'c' when the odds ratios are equal for a two-way & three-way market.  

***

### Definitions

For a two-way betting market we will use the following definitions:  

* `1/p` & `1/q` are 'true' odds; where `p` & `q` are the 'true' probabilities of events `p` & `q` occurring
* similarly `1/x` & `1/y` are bookmakers odds; where `x` & `y` are the implied probabilities
* `v` is the overround of the bookmakers market and thus $v \ge 1$


For a three-way betting market we extend to: 

* `p, q & r` for 'true' probabilities
* `x, y & z` for the bookmakers probabilities


Note that:

* We have $p + q = 1$ (or $p + q + r = 1$ for a three-way market)
* We have $x + y = v$ (or $x + y + z = v$)

***


### Function Definitions

For a given event with probability `p` & corresponding bookmakers probability `x`:

* Define the yield to be $$ Yield(x,p) = \dfrac{p}{x} - 1 $$
* Define the odds ratio to be $$ OR(x,p) = \dfrac{x/(1-x)}{p/(1-p)} $$

Here are these definitions as r functions: 

```{r yield function, echo=TRUE}

yield <- function(bookmakers_prob, true_prob){
  
  x <- bookmakers_prob
  p <- true_prob
  
  # check are numbers and have length 1
  stopifnot(is.numeric(x) && is.numeric(p))
  stopifnot(length(x) == 1 && length(p)==1)
  
  # output
  x/p - 1
}
```


```{r odds ratio function, echo=TRUE}
odds_ratio <- function(bookmakers_prob, true_prob){
  
  x <- bookmakers_prob
  p <- true_prob
  
  # check are numbers and have length 1
  stopifnot(is.numeric(x) && is.numeric(p))
  stopifnot(length(x) == 1 && length(p)==1)
  
  # output
  (x/(1-x)) / (p/(1-p))
}

```



We will use the following solvers to find the value `c` when the odds ratios are equivalent for each event of the market.  
The method defined in the article is a way to find the bookmakers odds from the true probabilities, 
but we will make the input to the solver ambiguous so we can supply either set of odds and simply find `c`. 

```{r solver two-way market, echo=TRUE}


two_way_market_Solver <- function(odds_1, odds_2, overround){
  
  # check inputs are all numeric & length == 1
  stopifnot(all(is.numeric(odds_1), is.numeric(odds_2), is.numeric(overround)))
  stopifnot(all(length(odds_1) == 1, length(odds_2) == 1, length(overround) == 1))
  
  # adjust odds to probabilities
  p <- 1/odds_1
  q <- 1/odds_2
  
  # solver function: minimise 'x + y - v' to find c such that x + y = v
  find_c <- function(c){
    abs((c*p/(1-p+c*p)) + (c*q/(1-q+c*q)) - overround)
  }
  
  # use optim to solve with lower bound to prevent -ve roots
  optimised_solver <- optim(
    par = c(1), fn = find_c, method = "Brent", lower = 1e-03, upper = 1e+03
  )
  
  # output parameter from optim
  optimised_solver$par[1]
}

```


```{r solver - three-way market, echo=TRUE}

three_way_market_Solver <- function(odds_1, odds_2, odds_3, overround){
  
  # check inputs are all numeric & length == 1
  stopifnot(all(is.numeric(odds_1), is.numeric(odds_2), is.numeric(odds_3), is.numeric(overround)))
  stopifnot(all(length(odds_1) == 1, length(odds_2) == 1, length(odds_3) == 1, length(overround) == 1))
  
  # adjust odds to probabilities
  p <- 1/odds_1
  q <- 1/odds_2
  r <- 1/odds_3
  
  # solver function: minimise 'x + y - v' to find c such that x + y = v
  find_c <- function(c){
    abs((c*p/(1-p+c*p)) + (c*q/(1-q+c*q)) + (c*r/(1-r+c*r)) - overround)
  }
  
  # use optim to solve with lower bound to prevent -ve roots
  optimised_solver <- optim(
    par = c(1), fn = find_c, method = "Brent", lower = 1e-03, upper = 1e+03
  )
  
  # output parameter from optim
  optimised_solver$par[1]
}


```



### Two-Way Market Table


```{r two-way market table, echo=FALSE}


# create table
two_way_market_table <- tibble(
  `1/p` = c(seq(from = 2, to = 1.08, by = -0.04), 1.06, 1.04, 1.02, 1.01)  # by -0.04, for > 1.08; more granular < 1.08
  ) %>% 
  mutate(
    `1/q` = 1/(1-(1/`1/p`)), 
    v = 1.081  # v = overround
  ) %>% 
  mutate(
    p = 1/`1/p`,          # add p & q for easier calculations later
    q = 1/`1/q` 
  )


# derive c with solver, add xy, yields & odds ratios
two_way_market_table <- two_way_market_table %>% 
  mutate(
    c = pmap_dbl(list(two_way_market_table$`1/p`, two_way_market_table$`1/q`, two_way_market_table$v), two_way_market_Solver)
  ) %>% 
  mutate(
    x = c*p/(1-p+c*p),
    y = c*q/(1-q+c*q), 
    `1/x` = 1/x, 
    `1/y` = 1/y
  ) %>% 
  mutate(
    yield_x = p*`1/x` - 1, 
    yield_y = q*`1/y` - 1, 
    odds_ratio_x_p = (x/(1-x)) / (p/(1-p)), 
    odds_ratio_y_q = (y/(1-y)) / (q/(1-q)) 
  )


# collect columns in the order as shown on the webpage
two_way_market_table <- two_way_market_table %>% 
  select(`1/p`, `1/q`, `1/x`, `1/y`, v, yield_x, yield_y, odds_ratio_x_p, odds_ratio_y_q) %>% 
  head(10)

# table output
kable(
  two_way_market_table, 
  col.names = c("1/p", "1/q", "1/x", "1/y", "v", "Y(x)", "Y(y)", "OR(x,p)", "OR(y,q)"), 
  digits = c( 2, 2, 2, 2, 4, 3, 3, 3, 3)
)


```


***

### Three-Way Market Table

```{r three-way market table, echo=FALSE}


# create table with made up sequence of odds
three_way_market_table <- tibble(
  `1/p` = seq(from = 1.6, to = 1.2, by = -0.05), 
  `1/q` = seq(from = 8, to = 16, by = 1)
  ) %>% 
  mutate(
    `1/r` = 1/(1-(1/`1/p`)-(1/`1/q`))
  )




```
